import datetime as dt

# Можно лучше: Нужна пустая строка после декларации класса. Потому что согласно PEP-8:
#              "Method definitions inside a class are surrounded by a single blank line".
#              Аналогично и для классов Calculator и CaloriesCalculator
class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        # Можно лучше: Здесь лишние переносы строк и вообще конструкция выглядит трудночитаемой. Лучше отдельной строкой
        #              объявить переменную date_default = dt.datetime.now(), и отдельной строкой привести переменную
        #              date к типу str. Кроме того, обработку аргумента date лучше исполнять внутри блока try-except,
        #              потому что если пользователь передаст дату в другом формате, нежели '%d.%m.%Y', будет ошибка. В
        #              таком случае мы обработаем эту ошибку, укажем date = None и будем использовать текущую дату по
        #              умолчанию (date_default).
        #              В итоге переменную self.date можно объявить без if-else, просто self.date = date or date_default
        self.date = (
            dt.datetime.now().date() if
            not
            date else dt.datetime.strptime(date, '%d.%m.%Y').date())
        self.comment = comment


class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    def add_record(self, record):
        self.records.append(record)

    def get_today_stats(self):
        # Можно лучше: Можно использовать list comprehension, чтобы отфильтровать записи нужной даты, а потом просто
        #              вычислить сумму amount этих записей, например:
        #              today = dt.datetime.now().date()
        #              today_stats = sum(record.amount for record in self.records if record.date == today)
        #              List comprehension в python это не только "синтаксический сахар", данная конструкция работает
        #              быстрее, чем обычый цикл for, а быстродействие программы в реальной жизни зачастую очень важна.
        #              Подробнее тут: https://wiki.python.org/moin/PythonSpeed/PerformanceTips#Loops
        today_stats = 0
        # Можно лучше: Согласно PEP-8 названия таких переменных, как Record в данном случае, должны быть строчными
        #              буквами, то есть record. Кроме того, мы уже имеем класс Record, который мы уже не сможем
        #              упомянуть в данном методе, потому что его имя теперь будет присвоено переменной (на случай,
        #              например, если в self.records у нас будут храниться сущности разных классов и мы захотим
        #              проверять, является ли объект сущностью класса Record).
        for Record in self.records:
            if Record.date == dt.datetime.now().date():
                # Можно лучше: Такие операции практически во всех современных языках программирования принято писать
                #              как today_stats += today_stats. Так код легче читается.
                today_stats = today_stats + Record.amount
        return today_stats

    def get_week_stats(self):
        week_stats = 0
        # Отлично: Да, такие сущности лучше заранее определять в качестве переменной и затем уже использовать ее.
        today = dt.datetime.now().date()
        # Можно лучше: Опять же можно использовать list comprehension, например:
        #             week_stats = sum(record.amount for record in self.records if 0 <= (today - record.date).days <= 7)
        for record in self.records:
            # Можно лучше: Два условия можно сократить до одного: if 0 <= (today - record.date).days <= 7:
            if (
                (today - record.date).days < 7 and
                (today - record.date).days >= 0
            ):
                # Отлично: Используем общепринятый оператор +=, и код сразу легко читается
                week_stats += record.amount
        return week_stats


class CaloriesCalculator(Calculator):
    # Можно лучше: Согласно PEP-8 необходимо использовать docstring комментарий к функциям. То есть нужно перенести
    #              комментарий на новую строку и заключить его в тройные кавычки, вот так:
    #              """Получает остаток калорий на сегодня."""
    #              Подробнее тут: https://www.python.org/dev/peps/pep-0257/
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        # Можно лучше: Название переменной x не соответствует требованию: "Переменные названы в соответствии с их
        #              смыслом, нет однобуквенных названий". Лучше переименовать перемунную x например
        #              в limit_remained. А еще лучше избавиться от переменной и просто сравнить self.limit и
        #              self.get_today_stats() в условии if.
        x = self.limit - self.get_today_stats()
        if x > 0:
            # Надо исправить: Перенос строки нарушает требование: "Бэкслеши для переносов не применяются". В таком
            #                 случае можно использовать многострочную строку с тройными кавычками. Однако в данном
            #                 случае текст помещается и в одну строку (тут меньше 79 символов). И в "что-нибудь  ещё,"
            #                 двойной пробел.
            #                 Кроме того, ответ можно сначала записать в переменную, а заметем вернуть эту переменную,
            #                 если это повысит читаемость кода.
            return f'Сегодня можно съесть что-нибудь ' \
                   f' ещё, но с общей калорийностью не более {x} кКал'
        # Надо испровить: Пункт else в данном случае избыточный и нарушает требование: "Нет лишних else там, где они
        #                  не нужны (если в if происходит return/raise); используется Guard Block". В данном можно сразу
        #                  возвращать 'Хватит есть!' без "else:".
        else:
            # Надо испровить: Скобки избыточны, достаточно просто указать return 'Хватит есть!'.
            return('Хватит есть!')


class CashCalculator(Calculator):
    # Можно лучше: Зачем float(60), когда можно просто 60. (с точкой)? Читается проще и работает немного быстрее.
    #              То же самое и для строки EURO_RATE = float(70).
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.

    # Можно лучше: Согласно PEP-8 названия переменных должны быть строчными буквами, соответственно параметры USD_RATE и
    #              и EURO_RATE лучше переименовать строчными буквами. Да константы принято называть заглавными буквами.
    #              Но здесь важно различать константы (которые мы не хотим, чтобы менялись в процессе работы программы)
    #              и параметры функции (которые могут меняться в зависимости от данных, которые передаются при вызове
    #              метода).
    #              Помимо этого тут перенос строки, оба параметра помещаются в одну строку и не ухудшают читаемость кода.
    def get_today_cash_remained(self, currency,
                                USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        # Можно лучше: Тут лучше составить словарь, где ключами будут ожидаемые варианты значения переменной currency,
        #              а значениями - словарь с данными об отображаемом названим валюты и величине конвертации к рублю.
        #              Например: currencies = dict(usd=dict(alias='USD', rate=USD_RATE), ...). Это позволит избежать
        #              использования if-else конструкции. Вместо этого можно будет обойтись строками:
        #              currency_info = currencies.get(currency, {}) и далее:
        #              cash_remained /= currency_info.get('rate', 1) и
        #              currency_type = currency_info.get('alias', 'руб')
        #`             Это позволит не только упростить читаемость кода, но еще и обеспечит возможность легкого
        #              масштабирования программы. Например, если мы захотим добавить поддержку других валют, то не нужно
        #              будет расписывать новые elif случаи, а достаточно будет просто добавить новую валюту в словарь.
        currency_type = currency
        cash_remained = self.limit - self.get_today_stats()
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            # Надо исправить: Эта строка сравнивает cash_remained с 1.00, то есть она здесь не несет никакой смысловой
            #                 нагрузки, и ее можно убрать.
            cash_remained == 1.00
            currency_type = 'руб'
        # Можно лучше: Нет случая else. То есть, например, если пользователь передаст в качестве значения currency
        #              "BTC", то метод вернет ответ для рублей, при этом напишет не "руб", а "rub". Возможно тут имеет
        #              смысл выдать ошибку или предусмотреть иное поведение программы.
        if cash_remained > 0:
            return (
                # Можно лучше: Лишний перенос строки и лишние скобки для оператора return - это все лучше убрать.
                #              Кроме того у нас есть требование: "В f-строках применяется только подстановка переменных
                #              и нет логических или арифметических операций, вызовов функций и подобной динамики",
                #              поэтому лучше определить переменную, где cash_remained станет строкой с нужным
                #              округлением и уже эту переменную использовать в f-строке.
                # Можно лучше: Согласно заданию сумма должна быть округлена "до двух знаков после запятой (до сотых)".
                #              Однако функция round(3.000, 2) сделает строку "3.0". Поэтому в данном случае лучше
                #              использовать специальный оператор f-строки, например так: f'{cash_remained:.2f}'
                f'На сегодня осталось {round(cash_remained, 2)} '
                f'{currency_type}'
            )
        elif cash_remained == 0:
            return 'Денег нет, держись'
        # Можно лучше: В данном случае пункт "elif cash_remained < 0:" избыточный. Если программа долшла до это строки,
        #              то это уже означает, что cash_remained < 0 (Помним про требование "Нет лишних else там, где они
        #              не нужны (если в if происходит return/raise); используется Guard Block").
        elif cash_remained < 0:
            # Можно лучше: Лишний перенос строки, все умещается в одну строку. Кроме того, использование метода format
            #              нарушает принцип единообразия, ведь везде в коде используются f-строки.
            return 'Денег нет, держись:' \
                   ' твой долг - {0:.2f} {1}'.format(-cash_remained,
                                                     currency_type)

    def get_week_stats(self):
        # Надо исправить: Функция не работает так, как ожидается, поскольку она ничего не возвращает. То есть, например,
        #                 CashCalculator(10).get_week_stats() вернет None. То же самое будет, если добавить в
        #                 калькулятор записи. Кроме того, класс CashCalculator наследует метод get_week_stats() от
        #                 родительского класса Calculator, поэтому здесь этот метод можно не определять.
        super().get_week_stats()
# Надо исправить: Не выполнен пункт 3 задания "Чтобы своими глазами увидеть, что ваши классы работают правильно,
#                 напишите какой-нибудь сценарий их использования". При этом нужно учесть и это требование: "Исполняемый
#                 код в .py-файлах должен быть закрыт конструкцией if __name__ == ‘__main__’. Таким образом мы убедимся,
#                 что все работает так, как ожидается, при этом эта проверка не будет выполняться, если мы импортируем
#                 данный модуль, в другом python файле.
# Можно лучше: Согласно PEP-8 файл .py должен оканчиваться пустой строкой.
# Отлично: Оба калькулятора работают корректно за исключением случая с методом get_week_stats(). В основном замечания
#          связаны с читаемостью кода. Отличная работа!